# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Bejo_UpdateMapDialog
                                 A QGIS plugin
 Update peta seismic dengan database CSV
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-12-26
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Aryo Danang
        email                : aryodanang04@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
import csv
from PyQt5.QtWidgets import QTableWidget, QTableWidgetItem, QFileDialog, QMessageBox

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'Bejo_UpdateMap_dialog_base.ui'))


class Bejo_UpdateMapDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(Bejo_UpdateMapDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)


        ################# hapus mulai sini
        self.tableWidget
        self.opButton.clicked.connect(self.open_csv_file)
        #self.filterLine.currentIndexChanged.connect(self.filter_table)
        # Isi comboBox kedua dengan item statis
        self.populate_static_combobox()
        #update csv
        # self.updateButton.clicked.connect(self.update_csv)
        self.updateButton.clicked.connect(self.update_csv_and_refresh_table)
        

################################################################## hapus mulai dari sini
    def open_csv_file(self):
        # Dialog untuk memilih file CSV
        file_path, _ = QFileDialog.getOpenFileName(
            None, "Pilih File CSV", "", "CSV Files (*.csv)"
        )

        if not file_path:
            return  # Jika file tidak dipilih

        try:
            # menampilkan path file di line edit
            self.pathFile.setText(file_path)

            with open(file_path, 'r') as file:
                reader = csv.reader(file)
                headers = next(reader)  # Baris pertama sebagai header
                rows = list(reader)

            self.fill_table(headers, rows)

            # Isi ComboBox dengan nilai unik dari kolom pertama
            self.populate_combobox(rows)

        except Exception as e:
            QMessageBox.critical(None, "Error", f"Gagal membuka file CSV:\n{e}")

    def fill_table(self, headers, rows):
        # Atur jumlah baris dan kolom
        self.tableWidget.setRowCount(len(rows))
        self.tableWidget.setColumnCount(len(headers))
        self.tableWidget.setHorizontalHeaderLabels(headers)

        # Isi tabel dengan data
        for row_index, row_data in enumerate(rows):
            for col_index, cell_data in enumerate(row_data):
                self.tableWidget.setItem(row_index, col_index, QTableWidgetItem(cell_data))

    def populate_combobox(self, rows):
        # Ambil nilai unik dari kolom pertama
        unique_values = set(row[0] for row in rows)

        # Bersihkan item yang ada di ComboBox filterLine
        self.filterLine.clear()

        # Tambahkan nilai unik ke ComboBox filterLine
        self.filterLine.addItems(sorted(unique_values))

    # def filter_table(self):
    #     selected_value = self.filterLine.currentText()
    #     for row in range(self.tableWidget.rowCount()):
    #         item = self.tableWidget.item(row, 0)
    #         if item.text() == selected_value or not selected_value:
    #             self.tableWidget.setRowHidden(row, False)
    #         else:
    #             self.tableWidget.setRowHidden(row, True)

    def populate_static_combobox(self):
        # Tambahkan item statis ke comboBox kedua
        self.progressType.clear()
        self.progressType.addItems(["NONE","Survey", "Clearing","Drilled","Shoot","Deploy","PickedUp","Checked","Pinging","Hazard"])



######################################################
    #fungsi untuk mengupdate data
######################################################
    def get_filter_values(self):
        # Nilai dari ComboBox filterLine
        filter_line_value = self.filterLine.currentText()

        # Nilai dari ComboBox progressType
        progress_type_value = self.progressType.currentText()

        # Rentang nomor dari LineEdit
        from_number = self.fromText.text()
        to_number = self.toText.text()

        # Nilai dari LineEdit crewText dan remarkText
        crew_text_value = self.crewText.text()
        remark_text_value = self.remarkText.text()

        # Nilai dari QgsDateTimeEdit tanggalUpdate
        date_update_value = self.tanggalUpdate.dateTime().toString("yyyy-MM-dd")

        return filter_line_value, progress_type_value, from_number, to_number, crew_text_value, remark_text_value, date_update_value
######################################################
    def filter_and_update_csv_data(self, rows):
        # Ambil nilai filter dan update dari UI
        filter_line_value, progress_type_value, from_number, to_number, crew_text_value, remark_text_value, date_update_value = self.get_filter_values()

        # Validasi rentang nomor
        try:
            from_number = int(from_number) if from_number else 0
            to_number = int(to_number) if to_number else 0

            # Tukar jika dari lebih besar daripada sampai
            if from_number > to_number:
                from_number, to_number = to_number, from_number

        except ValueError:
            QMessageBox.critical(self, "Error", "Rentang nomor harus berupa angka valid.")
            return []

        # Filter dan perbarui data
        updated_rows = []
        for row in rows:
            try:
                # Filter berdasarkan filterLine (kolom pertama) dan rentang nomor (kolom kedua)
                if row[0] != filter_line_value:
                    updated_rows.append(row)
                    continue

                row_number = int(row[1])  # Kolom nomor diindeks sebagai kolom kedua
                if not (from_number <= row_number <= to_number):
                    updated_rows.append(row)
                    continue

                # Perbarui kolom-kolom yang sesuai
                row[5] = progress_type_value  # Update kolom ke-6 (indeks 5)
                row[6] = crew_text_value      # Update kolom ke-7 (indeks 6)
                row[7] = remark_text_value    # Update kolom ke-8 (indeks 7)
                row[8] = date_update_value    # Update kolom ke-9 (indeks 8)

                updated_rows.append(row)
            except (IndexError, ValueError):
                # Abaikan baris yang tidak valid
                updated_rows.append(row)

        return updated_rows

###################################################### saveto csv
    def save_to_csv(self, updated_rows):
        # Ambil path file dari QLineEdit yang berisi path file
        file_path = self.pathFile.text()
        if not file_path:
            QMessageBox.warning(self, "Error", "Path file tidak ditemukan.")
            return

        # Tulis data ke file CSV
        try:
            with open(file_path, 'w', newline='', encoding='utf-8') as file:
                writer = csv.writer(file)

                # Header CSV (gantilah dengan header asli dari file Anda jika ada)
                # headers = ["Column1", "Column2", "Column3", "Column4", "Column5", "Column6", "Column7", "Column8", "Column9"]
                # writer.writerow(headers)

                # Tulis baris data yang telah diperbarui
                writer.writerows(updated_rows)

            QMessageBox.information(self, "Berhasil", "File CSV berhasil diperbarui.")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Gagal menyimpan file CSV: {e}")

###################################################### update to csv
    def update_csv(self):
        # Ambil path file dari QLineEdit yang berisi path file
        file_path = self.pathFile.text()
        if not file_path:
            QMessageBox.warning(self, "Error", "Path file tidak ditemukan.")
            return

        # Membaca data dari file CSV
        try:
            with open(file_path, 'r', encoding='utf-8') as file:
                reader = csv.reader(file)
                rows = list(reader)

                # Ambil header dan data
                headers = rows[0]
                data_rows = rows[1:]

                # Filter dan perbarui data
                updated_rows = self.filter_and_update_csv_data(data_rows)

                # Simpan data yang telah diperbarui
                self.save_to_csv([headers] + updated_rows)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Gagal membaca file CSV: {e}")


####################### refresh table
    def update_csv_and_refresh_table(self):
        # Update the CSV file
        self.update_csv()

        # Reload the updated CSV data
        self.load_csv_to_table()

    def load_csv_to_table(self):
        # Path to the CSV file from the QLineEdit
        file_path = self.pathFile.text()
        if not file_path:
            QMessageBox.warning(self, "Error", "Path file tidak ditemukan.")
            return

        try:
            # Open and read the CSV file
            with open(file_path, 'r', encoding='utf-8') as file:
                reader = csv.reader(file)
                rows = list(reader)

                # Clear the QTableWidget
                self.tableWidget.clear()

                # Set table headers from the first row (optional)
                headers = rows[0]
                self.tableWidget.setColumnCount(len(headers))
                self.tableWidget.setHorizontalHeaderLabels(headers)

                # Populate the table with data
                self.tableWidget.setRowCount(len(rows) - 1)  # Exclude header row
                for row_index, row in enumerate(rows[1:], start=0):
                    for col_index, cell in enumerate(row):
                        self.tableWidget.setItem(row_index, col_index, QTableWidgetItem(cell))

        except Exception as e:
            QMessageBox.critical(self, "Error", f"Gagal memuat file CSV: {e}")
